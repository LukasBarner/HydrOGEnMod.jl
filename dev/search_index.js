var documenterSearchIndex = {"docs":
[{"location":"mathematical_formulation/#Mathematical-Formulation","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"","category":"section"},{"location":"mathematical_formulation/#Notation","page":"Mathematical Formulation","title":"Notation","text":"","category":"section"},{"location":"mathematical_formulation/#Player-Optimization-Problems","page":"Mathematical Formulation","title":"Player Optimization Problems","text":"","category":"section"},{"location":"mathematical_formulation/#Complementarity-Problem","page":"Mathematical Formulation","title":"Complementarity Problem","text":"","category":"section"},{"location":"mathematical_formulation/#Convex-Reformulation","page":"Mathematical Formulation","title":"Convex Reformulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HydrOGEnMod","category":"page"},{"location":"#HydrOGEnMod","page":"Home","title":"HydrOGEnMod","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for HydrOGEnMod.jl. Please see the Mathematical section for mathematical derivations, Documentation section for implementation details, and the Replication section for a script with a more detailed application. ","category":"page"},{"location":"replication/#Replication","page":"Replication","title":"Replication","text":"","category":"section"},{"location":"replication/","page":"Replication","title":"Replication","text":"To run the replication script, you may use the following code: ","category":"page"},{"location":"replication/","page":"Replication","title":"Replication","text":"using HydrOGEnMod\nusing Gurobi\nusing JuMP\n\npc_results_path = joinpath(dirname(dirname(pathof(HydrOGEnMod))), \"results\", \"pc\")\n\ndata_pc = get_HydrOGEnMod_data(\n    joinpath(dirname(dirname(pathof(HydrOGEnMod))), \"data\", \"data_pc\")\n);\nwrite_csv(joinpath(pc_results_path, \"precalculated\"), data_pc)\n\nmodel_pc = build_optimization_model(data_pc)\n\noptimize!(model_pc, Gurobi.Optimizer)\nwrite_csv(pc_results_path, model_pc)\n\nfor y in [2030, 2050], c in [\"GH2\", \"NH3\", \"LH2\"]\n    for s in [\"L\", \"H\"]\n        if c ∉ [\"LH2\"]\n            plot_model_nodes(\n                value.(model_pc[:prices][:, c, \"Block 1\", s, y]);\n                map_title = \"Prices for $c in Season $s $y Perfect Competition\",\n                save_path = joinpath(\n                    pc_results_path,\n                    \"graphics\",\n                    \"pc_prices_$(c)_$(s)_$(y).pdf\",\n                ),\n                rasterize = 1,\n            )\n            plot_model_nodes(\n                value.(model_pc[:demand][:, c, \"Block 1\", s, y]);\n                map_title = \"Demand for $c in Season $s $y Perfect Competition\",\n                save_path = joinpath(\n                    pc_results_path,\n                    \"graphics\",\n                    \"pc_demand_$(c)_$(s)_$(y).pdf\",\n                ),\n                rasterize = 1,\n            )\n        end\n    end\n\n    plot_model_nodes(\n        value.(model_pc[:yearly_demand][:, c, y]);\n        map_title = \"Annual Demand for $c in $y Perfect Competition\",\n        save_path = joinpath(pc_results_path, \"graphics\", \"pc_demand_$(c)_$(y).pdf\"),\n        rasterize = 1,\n    )\n\n    plot_model_nodes(\n        value.(model_pc[:yearly_production][:, c, y]);\n        map_title = \"Annual Production for $c in $y Perfect Competition\",\n        save_path = joinpath(pc_results_path, \"graphics\", \"pc_production_$(c)_$(y).pdf\"),\n        geojson_property_tag = :MODEL_PRODUCER_5,\n        rasterize = 1,\n    )\n\n    plot_model_nodes(\n        value.(model_pc[:yearly_arc_flows][:, c, y]),\n        data_pc.arcs;\n        map_title = \"Largest Trade Flows $c $y Perfect Competition\",\n        save_path = joinpath(pc_results_path, \"graphics\", \"pc_trade_flows_$(c)_$(y).pdf\"),\n        colorscheme = :linear_gow_65_90_c35_n256,\n        linewidth = 2,\n        largestvalues = 50,\n        rasterize = 1,\n    )\n\n    for i in [\"Renewable Hydrogen\", \"Nuclear Hydrogen\"]\n        plot_model_nodes(\n            value.(model_pc[:yearly_input_procurement][:, i, y]);\n            map_title = \"Annual Procurement of $i in $y Perfect Competition\",\n            save_path = joinpath(\n                pc_results_path,\n                \"graphics\",\n                \"pc_procurement_$(i)_$(y).pdf\",\n            ),\n            geojson_property_tag = :MODEL_PRODUCER_5,\n            rasterize = 1,\n        )\n    end\nend\n\nmp_results_path = joinpath(dirname(dirname(pathof(HydrOGEnMod))), \"results\", \"mp\")\n\ndata_mp = get_HydrOGEnMod_data(\n    joinpath(dirname(dirname(pathof(HydrOGEnMod))), \"data\", \"data_mp\")\n);\n\nwrite_csv(joinpath(mp_results_path, \"precalculated\"), data_mp)\nmodel_mp = build_optimization_model(data_mp)\n\noptimize!(model_mp, Gurobi.Optimizer)\nwrite_csv(mp_results_path, model_mp)\nfor y in [2030, 2050], c in [\"GH2\", \"NH3\", \"LH2\"]\n    for s in [\"L\", \"H\"]\n        if c ∉ [\"LH2\"]\n            plot_model_nodes(\n                value.(model_mp[:prices][:, c, \"Block 1\", s, y]);\n                map_title = \"Prices for $c in Season $s $y Imperfect Competition\",\n                save_path = joinpath(\n                    mp_results_path,\n                    \"graphics\",\n                    \"mp_prices_$(c)_$(s)_$(y).pdf\",\n                ),\n                rasterize = 1,\n            )\n            plot_model_nodes(\n                value.(model_mp[:demand][:, c, \"Block 1\", s, y]);\n                map_title = \"Demand for $c in Season $s $y Imperfect Competition\",\n                save_path = joinpath(\n                    mp_results_path,\n                    \"graphics\",\n                    \"mp_demand_$(c)_$(s)_$(y).pdf\",\n                ),\n                rasterize = 1,\n            )\n        end\n    end\n\n    plot_model_nodes(\n        value.(model_mp[:yearly_demand][:, c, y]);\n        map_title = \"Annual Demand for $c in $y Imperfect Competition\",\n        save_path = joinpath(mp_results_path, \"graphics\", \"mp_demand_$(c)_$(y).pdf\"),\n        rasterize = 1,\n    )\n\n    plot_model_nodes(\n        value.(model_mp[:yearly_production][:, c, y]);\n        map_title = \"Annual Production for $c in $y Imperfect Competition\",\n        save_path = joinpath(mp_results_path, \"graphics\", \"mp_production_$(c)_$(y).pdf\"),\n        geojson_property_tag = :MODEL_PRODUCER_5,\n        rasterize = 1,\n    )\n\n    plot_model_nodes(\n        value.(model_mp[:yearly_arc_flows][:, c, y]),\n        data_mp.arcs;\n        map_title = \"Largest Trade Flows $c $y Imperfect Competition\",\n        save_path = joinpath(mp_results_path, \"graphics\", \"mp_trade_flows_$(c)_$(y).pdf\"),\n        colorscheme = :linear_gow_65_90_c35_n256,\n        linewidth = 2,\n        largestvalues = 50,\n        rasterize = 1,\n    )\n\n    for i in [\"Renewable Hydrogen\", \"Nuclear Hydrogen\"]\n        plot_model_nodes(\n            value.(model_mp[:yearly_input_procurement][:, i, y]);\n            map_title = \"Annual Procurement of $i in $y Imperfect Competition\",\n            save_path = joinpath(\n                mp_results_path,\n                \"graphics\",\n                \"mp_procurement_$(i)_$(y).pdf\",\n            ),\n            geojson_property_tag = :MODEL_PRODUCER_5,\n            rasterize = 1,\n        )\n    end\nend\n\ndiff_plots_path = joinpath(dirname(dirname(pathof(HydrOGEnMod))), \"results\", \"diff\")\n\nfor y in [2030, 2050]\n    for s in [\"L\", \"H\"], c in [\"GH2\", \"NH3\"]\n        plot_model_nodes(\n            value.((\n                model_mp[:prices][:, c, \"Block 1\", s, y] .-\n                model_pc[:prices][:, c, \"Block 1\", s, y]\n            ));\n            map_title = \"Price Difference against Perfect Competition $s $c $y\",\n            save_path = joinpath(diff_plots_path, \"diff_prices_$(c)_$(s)_$(y).pdf\"),\n            rasterize = 1,\n        )\n    end\n\n    for i in [\"Renewable Hydrogen\", \"Nuclear Hydrogen\"]\n        plot_model_nodes(\n            value.(\n                model_mp[:yearly_input_procurement][:, i, y] .-\n                model_pc[:yearly_input_procurement][:, i, y]\n            );\n            map_title = \"Difference in Annual Procurement of $i in $y Imperfect Competition\",\n            save_path = joinpath(diff_plots_path, \"diff_procurement_$(i)_$(y).pdf\"),\n            geojson_property_tag = :MODEL_PRODUCER_5,\n            rasterize = 1,\n        )\n    end\nend\n","category":"page"},{"location":"docstrings/","page":"Code Documentation","title":"Code Documentation","text":"CurrentModule = HydrOGEnMod","category":"page"},{"location":"docstrings/#Code-Documentation","page":"Code Documentation","title":"Code Documentation","text":"","category":"section"},{"location":"docstrings/","page":"Code Documentation","title":"Code Documentation","text":"","category":"page"},{"location":"docstrings/","page":"Code Documentation","title":"Code Documentation","text":"Modules = [HydrOGEnMod]","category":"page"},{"location":"docstrings/#HydrOGEnMod.build_complementarity_model","page":"Code Documentation","title":"HydrOGEnMod.build_complementarity_model","text":"build_complementarity_model(data::ModelData, BIG = 1e+6, logfile = \"\")\n\nBuild a JuMP model with complementarity extension from the underlying model data. \n\nA logfile and upper bounds on variables can be specified. \n\nExamples\n\njulia> using HydrOGEnMod\njulia> data = get_HydrOGEnMod_data(\"path/to/my/data\");\njulia> model = build_complementarity_model(data);\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HydrOGEnMod.build_optimization_model","page":"Code Documentation","title":"HydrOGEnMod.build_optimization_model","text":"build_optimization_model(data::ModelData, BIG = 1e+6, logfile = \"\")\n\nBuild a JuMP optimization model (QP) from the underlying model data. \n\nA logfile and upper bounds on variables can be specified. \n\nExamples\n\njulia> using HydrOGEnMod\njulia> data = get_HydrOGEnMod_data(\"path/to/my/data\");\njulia> model = build_optimization_model(data);\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HydrOGEnMod.get_HydrOGEnMod_data-Tuple{Any}","page":"Code Documentation","title":"HydrOGEnMod.get_HydrOGEnMod_data","text":"get_HydrOGEnMod_data(data; logfile = \"\")\n\nGet model data from the specified data path. \n\nA file where to write the log records can be specified via keyword arguments. \n\nExamples\n\njulia> using HydrOGEnMod\njulia> data = get_HydrOGEnMod_data(\"path/to/my/data\");\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HydrOGEnMod.plot_model_nodes-Tuple{Vector{HydrOGEnMod.HydrOGEnMod_Types.TransportArc}}","page":"Code Documentation","title":"HydrOGEnMod.plot_model_nodes","text":"plot_model_nodes(arcs::Vector{TransportArc}; nodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"), disputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"), centroids_path = joinpath(@__DIR__, \"maps\", \"centroids.csv\"), colorscheme = :seaborn_colorblind6, unassigned_color = :gray85, strokecolor = :black, strokewidth = 0.1, linewidth = 0.2, linecolor = :black, rasterize = false, save_path = \"\")\n\nPlot the passed arcs into the model node map. \n\nSeparate method implemented for also passing arc values.\n\nKeyword Arguments\n\nnodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"): Path where to find model nodes geojson file.\ndisputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"): Path where to find disputed areas geojson file.\ncentroids_path = joinpath(@__DIR__, \"maps\", \"centroids.csv\"): Path where to find model region centroids file.\ncolorscheme = :seaborn_colorblind6: Colorscheme for the model regions.\nunassigned_color = :gray85: Colorscheme for unassigned and disputed regions.\nstrokecolor = :black: Strokecolor around regions.\nstrokewidth = 0.1: Strokewidth around regions.\nlinewidth = 0.2: Arc linewidth connecting nodes.\nlinecolor = :black: Color of arcs connecting nodes.\nrasterize = false: Rasterization.\nsave_path = \"\": Where to save the resulting graphic. Ending of filename automatically implies file format. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HydrOGEnMod.plot_model_nodes-Tuple{}","page":"Code Documentation","title":"HydrOGEnMod.plot_model_nodes","text":"plot_model_nodes(; nodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"), disputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"), colorscheme = :seaborn_colorblind6, unassigned_color = :gray85, strokecolor = :black, strokewidth = 0.1, rasterize = false, legend_title = \"Node Names\", save_path = \"\",)\n\nPlot an overview of the model nodes. \n\nOnly active, if no positional argument is passed. \n\nKeyword Arguments\n\nnodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"): Path where to find model nodes geojson file.\ndisputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"): Path where to find disputed areas geojson file.\ncolorscheme = :seaborn_colorblind6: Colorscheme for the model regions.\nunassigned_color = :gray85: Colorscheme for unassigned and disputed regions.\nstrokecolor = :black: Strokecolor around regions.\nstrokewidth = 0.1: Strokewidth around regions.\nrasterize = false: Rasterization.\nlegend_title = \"Node Names\": Title of the legend.\nsave_path = \"\": Where to save the resulting graphic. Ending of filename automatically implies file format. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HydrOGEnMod.plot_model_nodes-Union{Tuple{JuMP.Containers.DenseAxisArray{T, N, Ax, L}}, Tuple{L}, Tuple{Ax}, Tuple{N}, Tuple{T}} where {T, N, Ax, L<:Tuple{Vararg{JuMP.Containers._AxisLookup, N}}}","page":"Code Documentation","title":"HydrOGEnMod.plot_model_nodes","text":"plot_model_nodes(container::JuMP.Containers.DenseAxisArray{T,N,Ax,L}; nodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"), disputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"), colorscheme = :plasma, unassigned_color = :gray85, strokecolor = :black, strokewidth = 0.1, rasterize = false, save_path = \"\") where {T,N,Ax,L<:NTuple{N,JuMP.Containers._AxisLookup}}\n\nPlot the values inside container into the model node map. \n\nSeparate methods implemented for DenseAxisArray and SparseAxisArray.\n\nKeyword Arguments\n\nnodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"): Path where to find model nodes geojson file.\ndisputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"): Path where to find disputed areas geojson file.\ncolorscheme = :plasma: Colorscheme for the model regions.\nunassigned_color = :gray85: Colorscheme for unassigned and disputed regions.\nstrokecolor = :black: Strokecolor around regions.\nstrokewidth = 0.1: Strokewidth around regions.\nrasterize = false: Rasterization.\nsave_path = \"\": Where to save the resulting graphic. Ending of filename automatically implies file format. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HydrOGEnMod.plot_model_nodes-Union{Tuple{JuMP.Containers.SparseAxisArray{T, N, K}}, Tuple{K}, Tuple{N}, Tuple{T}} where {T, N, K<:Tuple{Vararg{Any, N}}}","page":"Code Documentation","title":"HydrOGEnMod.plot_model_nodes","text":"plot_model_nodes(container::JuMP.Containers.SparseAxisArray{T,N,K}; nodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"), disputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"), colorscheme = :plasma, unassigned_color = :gray85, strokecolor = :black, strokewidth = 0.1, rasterize = false, save_path = \"\")\n\nPlot the values inside container into the model node map. \n\nSeparate methods implemented for DenseAxisArray and SparseAxisArray.\n\nKeyword Arguments\n\nnodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"): Path where to find model nodes geojson file.\ndisputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"): Path where to find disputed areas geojson file.\ncolorscheme = :plasma: Colorscheme for the model regions.\nunassigned_color = :gray85: Colorscheme for unassigned and disputed regions.\nstrokecolor = :black: Strokecolor around regions.\nstrokewidth = 0.1: Strokewidth around regions.\nrasterize = false: Rasterization.\nsave_path = \"\": Where to save the resulting graphic. Ending of filename automatically implies file format. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HydrOGEnMod.plot_model_nodes-Union{Tuple{L}, Tuple{Ax}, Tuple{N}, Tuple{T}, Tuple{JuMP.Containers.DenseAxisArray{T, N, Ax, L}, Vector{HydrOGEnMod.HydrOGEnMod_Types.TransportArc}}} where {T, N, Ax, L<:Tuple{Vararg{JuMP.Containers._AxisLookup, N}}}","page":"Code Documentation","title":"HydrOGEnMod.plot_model_nodes","text":"plot_model_nodes(container::JuMP.Containers.DenseAxisArray{T,N,Ax,L}, arcs::Vector{TransportArc}; nodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"), disputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"), centroids_path = joinpath(@__DIR__, \"maps\", \"centroids.csv\"), colorscheme = :seaborn_colorblind6, unassigned_color = :gray85, strokecolor = :black, strokewidth = 0.1, linewidth = 1, linecolorscheme = :plasma, rasterize = false, largestvalues = 10, save_path = \"\") where {T,N,Ax,L<:NTuple{N,JuMP.Containers._AxisLookup}}\n\nPlot the passed arcs with coloring corresponding to given values in the container into the model node map. \n\nSeparate method implemented for just plotting normal values.\n\nKeyword Arguments\n\nnodes_path = joinpath(@__DIR__, \"maps\", \"WB_countries_Admin0_modified.geojson\"): Path where to find model nodes geojson file.\ndisputed_path = joinpath(@__DIR__, \"maps\", \"WB_Admin0_disputed_areas_modified.geojson\"): Path where to find disputed areas geojson file.\ncentroids_path = joinpath(@__DIR__, \"maps\", \"centroids.csv\"): Path where to find model region centroids file.\ncolorscheme = :seaborn_colorblind6: Colorscheme for the model regions.\nunassigned_color = :gray85: Colorscheme for unassigned and disputed regions.\nstrokecolor = :black: Strokecolor around regions.\nstrokewidth = 0.1: Strokewidth around regions.\nlinewidth = 1: Arc linewidth connecting nodes.\nlinecolorscheme = :plasma: Colorscheme for coloring arcs connecting regions based on container values.\nrasterize = false: Rasterization.\nlargestvalues = 10: The n largest arc values and equal to select.\nminval = 1: The smallest value to include in the arc plot.\nsave_path = \"\": Where to save the resulting graphic. Ending of filename automatically implies file format.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HydrOGEnMod.solve_mcp-Tuple{JuMP.Model}","page":"Code Documentation","title":"HydrOGEnMod.solve_mcp","text":"solve_mcp(model::Model; logfile = \"\", kwargs...)\n\nSolve a JuMP model with complementarity extension using the PATH solver. \n\nA logfile can be specified, and solver specific options can be passed.\n\nExamples\n\njulia> using HydrOGEnMod\njulia> data = get_HydrOGEnMod_data(\"path/to/my/data\");\njulia> model = build_complementarity_model(data);\njulia> solve_mcp(model; output = \"no\", time_limit = 5);\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HydrOGEnMod.write_csv-Tuple{Any, HydrOGEnMod.HydrOGEnMod_Types.ModelData}","page":"Code Documentation","title":"HydrOGEnMod.write_csv","text":"write_csv(datadir, data::ModelData; logfile = \"\")\n\nWrite model data to a specific directory. \n\nA logfile can be specified.\n\nExamples\n\njulia> using HydrOGEnMod\njulia> data = get_HydrOGEnMod_data(\"path/to/my/data\");\njulia> write_csv(\"path/to/my/dir\",data);\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HydrOGEnMod.write_csv-Tuple{Any, JuMP.Model}","page":"Code Documentation","title":"HydrOGEnMod.write_csv","text":"write_csv(resultsfile, model::Model; logfile = \"\")\n\nWrite model results to a specific directory. \n\nA logfile can be specified.\n\nExamples\n\njulia> data = get_HydrOGEnMod_data(\"path/to/my/data\");\njulia> model = build_optimization_model(data);\njulia> optimize!(model, Ipopt.Optimizer);\njulia> write_csv(\"path/to/my/dir\", model);\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#JuMP.optimize!-Tuple{JuMP.Model, Any, Vararg{Any}}","page":"Code Documentation","title":"JuMP.optimize!","text":"optimize!(model::Model, optimizer; options..., logfile = \"\")\n\nSolve a JuMP Model with the given optimizer. \n\nA logfile can be specified, and solver specific options can be passed. \n\nExamples\n\njulia> using HydrOGEnMod\njulia> using Ipopt\njulia> data = get_HydrOGEnMod_data(\"path/to/my/data\");\njulia> model = build_optimization_model(data);\njulia> optimize!(model, Ipopt.Optimizer, \"max_wall_time\" => 1e-5)\n\n\n\n\n\n","category":"method"}]
}
